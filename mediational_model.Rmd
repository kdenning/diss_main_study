---
title: "Mediational Model"
output: 
    html_document:
      code_download: TRUE
      toc: TRUE
      toc_float:
        collapsed: FALSE
      toc_depth: 1
      code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r data prep, echo = FALSE, warning = FALSE, message = FALSE, error = FALSE}
# Loading packages
library(psych)
library(lme4)
library(nlme)
library(sjPlot)
library(effects)
library(magrittr) # part of the tidyverse but must be read in on its own
library(parameters)
library(dplyr)
library(tidyr)
library(rio)
library(ggplot2)
library(emmeans)
library(corrplot)

# Functions to clean document, get data from wide to long format
source("functions/Cleaning.R")

# Setting global chunk options
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)

options(scipen = 999)

# Importing data
wide_data <- import("data/diss_main_combined_data_basic_clean.csv")

# wide_data_sub <- wide_data %>%
#   select(sub_id,
#          bfi_self_1:eli_self_10,
#          bfi_ster_1:eli_stereo_10,
#          bfi_targ_1:eli_targ_10)
# 
# bias_counts <- apply(wide_data_sub, 1, function(x) length(which(x=="3")))
# bias_counts <- as.data.frame(bias_counts)
# 
# total_answers <- length(wide_data_sub)
# 
# # Used the sub_ids obtained from below in function above
# bias_counts %>%
#   mutate(bias_percents = (bias_counts/total_answers)*100) %>%
#   filter(bias_percents > 50)
# 
# 
# wide_data <- wide_data[-c(12, 17, 18, 22, 24, 31, 40, 70, 78, 82, 86, 87, 99, 
#                           112, 130, 131, 144, 145, 147, 154, 165, 166, 180, 192, 
#                           216, 247, 253, 258, 265, 275, 291, 293, 313, 324, 349,
#                           362, 375, 385, 387, 409, 410, 460, 474, 483, 486), ] 

# Cleaning data using functions
long_data_bfi <- get_wrangled_bfi(wide_data)
long_data_eli <- get_wrangled_eli(wide_data)

clean_vars_bfi <- get_vars_cleaned(long_data_bfi)
clean_vars_eli <- get_vars_cleaned(long_data_eli)

clean_data_bfi <- remove_participants(clean_vars_bfi)
clean_data_eli <- remove_participants(clean_vars_eli)

clean_data_bfi %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = scale(itt_comp, center = T, scale = F))

clean_data_eli %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = scale(itt_comp, center = T, scale = F))
```

# Exploring variance in intercepts for ELI

 https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

## Random intercept

```{r}
mod_1_data_eli <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_targ_pmc, eli_self_pmc, itt_comp_gmc,
         target_condition, eli_targ, eli_self) %>% 
  unique() %>% 
  na.omit() 

eli_randint_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (1 | sub_id), 
                   data = mod_1_data_eli) # Same as above, works with clean_data but not the smaller df specific to this analysis

summary(eli_randint_test)
```

The random variance for the intercept is 0, which is causing the singularity. This does not occur with the BFI. The data looks normal in the descriptives document. Checking some more stuff below.

### Checking individual intercepts/slopes

*Person mean centered variables*

```{r}
eli_coeffs_per_sub_c  <- lmList(eli_targ_pmc ~ 1 + eli_self_pmc | sub_id, mod_1_data_eli)
eli_coeffs_per_sub_c
```

*Uncentered variables*

```{r}
eli_coeffs_per_sub  <- lmList(eli_targ ~ 1 + eli_self | sub_id, mod_1_data_eli)
eli_coeffs_per_sub
```

There seems to be variability in the intercepts, even though lmer is not finding it.

### Scatterplot of variables

```{r}
ggplot(clean_data_eli, aes(eli_self_pmc, eli_targ_pmc)) +
  geom_point()
```

## Random Slopes/No random intercept

```{r}
eli_randslopes_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = mod_1_data_eli) 


summary(eli_randslopes_test)
```

Running without the random intercept fixes the issue

# Model 1: Threat on Counter-projection

## BFI

### Correlation matrix (multicolinearity)

```{r}
cor_predictors1 <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_self, bfi_targ, itt_comp) %>% 
  unique() %>% 
  na.omit() %>% 
  select(bfi_self, bfi_targ, itt_comp)

cor_matrix_predictors1 <- cor(cor_predictors1)
cor_matrix_predictors1

cor_plot_predictors1 <- corrplot(cor_matrix_predictors1, method = "number")

colnames(cor_plot_predictors1) = rep(c('BFI: Self',
                                       'BFI: Target',
                                       'Threat Composite'))

rownames(cor_plot_predictors1) = rep(c('BFI: Self',
                                       'BFI: Target',
                                       'Threat Composite'))
corrplot(cor_plot_predictors1, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         col.lim = c(0, 1),
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

### MLM Results

```{r}
model1_bfi <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc + 
                     (bfi_self_pmc | sub_id), 
                   data = mod_1_data_bfi) # Model only works with the whole data-set (clean_data), not when filtered down to only include observations (thus none repeated) for this analysis with mod_1_data_bfi

tab_model(model1_bfi,
          digits = 3)
```

#### Simple Slopes

```{r}
threat_levels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07))
mod1_simpslopes_bfi <- emtrends(model1_bfi, ~ itt_comp_gmc,
                              var ="bfi_self_pmc",
                              at = threat_levels)

mod1_simpslopes_bfi
```

#### Visualization

```{r}
mod1_bfi_maineffect <- effect("bfi_self_pmc:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07)),
                         mod = model1_bfi)

mod1_bfi_maineffect <- as.data.frame(mod1_bfi_maineffect)
mod1_bfi_maineffect$itt_comp_gmc <- as.factor(mod1_bfi_maineffect$itt_comp_gmc)

ggplot(mod1_bfi_maineffect, aes(bfi_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target-level \nthreat",
                        breaks = c(-1.07, 0, 1.07), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(title = "Projection by target-level threat",
         subtitle = "Using the BFI",
       x = "BFI responses for self",
       y = "BFI responses for target")
```

## ELI

### Correlation matrix (multicolinearity)

```{r}
cor_predictors_eli <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_self, eli_targ, itt_comp) %>% 
  unique() %>% 
  na.omit() %>% 
  select(eli_self, eli_targ, itt_comp)

cor_matrix_predictors_eli <- cor(cor_predictors_eli)
cor_matrix_predictors_eli

cor_plot_predictors_eli <- corrplot(cor_matrix_predictors_eli, method = "number")

colnames(cor_plot_predictors_eli) = rep(c('ELI: Self',
                                      'ELI: Target',
                                      'Threat Composite'))

rownames(cor_plot_predictors_eli) = rep(c('ELI: Self',
                                      'ELI: Target',
                                      'Threat Composite'))
corrplot(cor_plot_predictors_eli, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         col.lim = c(0, 1),
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

### MLM Results

```{r}
model1_eli_randslopes <- lmer(eli_targ_pmc ~ eli_self_pmc*itt_comp_gmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = mod_1_data_eli) # Same as above, works with clean_data but not the smaller df specific to this analysis


summary(model1_eli_randslopes)
tab_model(model1_eli_randslopes,
          digits = 3)
```

#### Simple Slopes

```{r}
mod1_simpslopes_eli <- emtrends(model1_eli_randslopes, ~ itt_comp_gmc,
                              var ="eli_self_pmc",
                              at = threat_levels)

mod1_simpslopes_eli
```

#### Visualization

```{r}
mod1_eli_maineffect <- effect("eli_self_pmc:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0, 1.07)),
                         mod = model1_eli_randslopes)

mod1_eli_maineffect <- as.data.frame(mod1_eli_maineffect)
mod1_eli_maineffect$itt_comp_gmc <- as.factor(mod1_eli_maineffect$itt_comp_gmc)

ggplot(mod1_eli_maineffect, aes(eli_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target-level \nthreat",
                        breaks = c(-1.07, 0, 1.07), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(title = "Projection by target-level threat",
         subtitle = "Using the ELI",
       x = "ELI responses for self",
       y = "ELI responses for target")
```

# Model 2: Instructions on threat

```{r}
mod2_data <- clean_data_bfi %>% 
  select(sub_id, itt_comp, analog_condition, target_condition) %>% 
  unique()

mod2 <- lm(itt_comp ~ analog_condition, data = mod2_data)
summary(mod2)
```

# Model 2b: Instructions x Target Variable on Threat

```{r}
mod2b <- lm(itt_comp ~ analog_condition*target_condition, data = mod2_data)
summary(mod2b)
```

# Models 3a and 3b: Mediated effect on projection without bootstrapping

## 3a: Target by condition on projection 

### BFI 

```{r}
mod3_data_bfi <- clean_data_bfi %>% 
  select(sub_id, bfi_self, bfi_self_pmc, bfi_targ, bfi_targ_pmc, itt_comp_gmc, 
         target_condition, analog_condition) %>% 
  unique()

mod3a_bfi <- lmer(bfi_targ ~ bfi_self_pmc*analog_condition*target_condition +
       (bfi_self_pmc| sub_id), data = mod3_data_bfi)
summary(mod3a_bfi)

tab_model(mod3a_bfi)
```

Analog does not appear to have an affect, so threat will have nothing to affect...

#### Checking without target condition

### ELI

```{r}
mod3_data_eli <- clean_data_eli %>% 
  select(sub_id, eli_self, eli_self_pmc, eli_targ, eli_targ_pmc, itt_comp_gmc, 
         target_condition, analog_condition) %>% 
  unique()

mod3a_eli <- lmer(eli_targ ~ eli_self_pmc*analog_condition*target_condition +
       (0 + eli_self_pmc | sub_id), data = mod3_data_eli)
summary(mod3a_eli)

tab_model(mod3a_eli)
```
 
 Still singular... even with random effects.
 
## 3b: Condition by threat composite on projection

### BFI 

```{r}
mod3b_bfi <- lmer(bfi_targ_pmc ~ bfi_self_pmc*analog_condition*target_condition*itt_comp_gmc +
       (bfi_self_pmc| sub_id), data = mod3_data_bfi)
summary(mod3b_bfi)

tab_model(mod3b_bfi)
```

This model is singular due to -1 correlation = it is overfit.

#### Checking if removing condition reduces overfitting

```{r}
mod3c_bfi <- lmer(bfi_targ_pmc ~ bfi_self_pmc*analog_condition*itt_comp_gmc +
       (bfi_self_pmc| sub_id), data = mod3_data_bfi)
summary(mod3c_bfi)

tab_model(mod3c_bfi)
```

It does not; maybe because analog does not have an effect

### ELI

```{r}

mod3b_eli <- lmer(eli_targ_pmc ~ eli_self_pmc*analog_condition*target_condition*itt_comp_gmc +
       (0 + eli_self_pmc | sub_id), data = mod3_data_eli)
summary(mod3b_eli)

tab_model(mod3b_eli)
```


Not sure what to do about overfitting and singularity with ELI- Regardless analog also has no effect. Maybe try with just the 5 that worked with the PSPB paper?

# Bootstrapping

Is there a point since I was only interested in the mediational effect explaining the effect of analogous perspective taking?

```{r}
# Set-up for mediational model -------------------------------------------------
# Getting the variables necessary for the model
data_4_med_bfi <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_targ_pmc, bfi_self_pmc, itt_comp_gmc, target_condition, analog_condition) %>% 
  unique() %>% 
  na.omit() 

# Getting empty df that is already the correct length
df_coeffs <- data.frame(matrix(vector(mode = 'numeric',length = 10000), nrow = 10000, ncol = 16))

# Renaming variables appropriately
df_coeffs %<>% 
  rename(a = X1,
         a_cil =  X2,
         a_ciu = X3,
         b = X4,
         b_cil = X5,
         b_ciu = X6,
         c = X7,
         c_cil = X8,
         c_ciu = X9,
         c_prime = X10,
         c_prime_cil = X11,
         c_prime_ciu = X12,
         coeff_int_on_cp = X13,
         int_on_cp_cil = X14,
         int_on_cp_ciu = X15,
         total = X16
         ) %>% 
  mutate(model = 1:10000)

# setting the seed
set.seed(123)

for (i in 1:10) {
  # Sample the df---------------------------------------------------------------
  df_samp <- data_4_med_bfi %>% 
  group_by(sub_id) %>% 
  sample_n(size = 19, replace = TRUE) #IS this doing anything?
  
  # Running model for non-mediated effect---------------------------------------
  pt_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*analog_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # Getting coefficients for direct effect of PT, non-mediated
  fixed_eff_pt_on_cp <- fixef(pt_on_cp) 
  c <- fixed_eff_pt_on_cp[4] # non mediated effect of analog pt on projection
  
  # Getting cis for non-mediated direct effect
  pt_on_cp_direct_ci <- confint(pt_on_cp,level=0.95)
  c_cil <- pt_on_cp_direct_ci[8,1]
  c_ciu <- pt_on_cp_direct_ci[8,2]
  
  # Running model on indirect effect--------------------------------------------
  pt_on_threat <- lm(itt_comp_gmc ~ analog_condition, data = df_samp)
  
  # Getting coefficient for indirect
  a <- pt_on_threat$coefficients[2] # effect of analog on threat; a
  
  # Getting indirect CI
  lm_ci <- confint(pt_on_threat,level=0.95)
  a_cil <- lm_ci[2,1]
  a_ciu <- lm_ci[2,2]
  
  # Running model on direct, mediated effect -----------------------------------
  threat_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc*analog_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # getting fixed effects from lmer into subsettable format
  fixed_eff <- fixef(threat_on_cp) 
  b <- fixed_eff[5] # effect of threat on projection; b
  c_prime <- fixed_eff[6] # effect of pt on projection after accounting for threat; c'
  int_on_cp_coeff <- fixed_eff[8] # interaction on projection; do I need this?
  
  # Getting CIs for lmer model
  indirect_ci <- confint(threat_on_cp,level=0.95)
  b_cil <- indirect_ci[9,1]
  b_ciu <- indirect_ci[9,2]
  c_prime_cil <- indirect_ci[10,1]
  c_prime_ciu <- indirect_ci[10,2]
  int_on_cp_cil <- indirect_ci[12,1]
  int_on_cp_ciu <- indirect_ci[12,2]
  
  # Putting coefficients into overall df----------------------------------------
  df_coeffs$a[i] <- a
  df_coeffs$a_cil[i] <- a_cil
  df_coeffs$a_ciu[i] <- a_ciu
  df_coeffs$b[i] <- b
  df_coeffs$b_cil[i] <- b_cil
  df_coeffs$b_ciu[i] <- b_ciu
  df_coeffs$c[i] <- c
  df_coeffs$c_cil[i] <- c_cil
  df_coeffs$c_ciu[i] <- c_ciu
  df_coeffs$c_prime[i] <- c_prime
  df_coeffs$c_prime_cil[i] <- c_prime_cil
  df_coeffs$c_prime_ciu[i] <- c_prime_ciu
  df_coeffs$int_on_cp_coeff[i] <- int_on_cp_coeff # do I need this?
  df_coeffs$int_on_cp_cil[i] <- int_on_cp_cil # do I need this?
  df_coeffs$int_on_cp_ciu[i] <- int_on_cp_ciu # do I need this?
  df_coeffs$total[i] <- df_coeffs$a[i]*df_coeffs$b[i]+df_coeffs$c_prime[i] # Tested for one model and total = c output, which is what it should be
}

```

Things to do/check:

Multicolinearity across levels?