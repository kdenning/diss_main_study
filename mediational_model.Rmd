---
title: "Mediational Model"
output: 
    html_document:
      code_download: TRUE
      toc: TRUE
      toc_float:
        collapsed: FALSE
      toc_depth: 1
      code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r data prep, echo = FALSE, warning = FALSE, message = FALSE, error = FALSE}
# Loading packages
library(psych)
library(lme4)
library(nlme)
library(sjPlot)
library(effects)
library(magrittr) # part of the tidyverse but must be read in on its own
library(parameters)
library(dplyr)
library(tidyr)
library(rio)
library(ggplot2)
library(emmeans)
library(corrplot)

# Functions to clean document, get data from wide to long format
source("functions/Cleaning.R")

# Setting global chunk options
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)

options(scipen = 999)

# Importing data
wide_data <- import("data/diss_main_combined_data_basic_clean.csv")

# Cleaning data using functions
long_data <- get_wrangled(wide_data)

clean_data <- remove_participants(long_data)

clean_data %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = scale(itt_comp, center = T, scale = F))
```

https://cran.r-project.org/web/packages/mlma/vignettes/MLMAvignette.html

https://journals.plos.org/plosone/article/file?type=printable&id=10.1371/journal.pone.0241072

I keep seeing the Bauer approach but it doesn't appear to use bootstrapping and I don't entirely understand it... Option 3 here makes sense to me, but would I do multiple models first and then this at the end?:
https://quantdev.ssri.psu.edu/sites/qdev/files/ILD_Ch07_2017_Within-PersonMedationWithMLM.html

Multicolinearity across levels?

# Exploring variance in intercepts

## BFI 

### With random intercept

*Tested basic model because singularities kept occurring.*

```{r}
mod_1_data_bfi <- clean_data %>% 
  select(sub_id, bfi_number, bfi_targ, bfi_targ_pmc, bfi_self, bfi_self_pmc, itt_comp_gmc, 
         target_condition, bfi_stereo) %>% 
  unique() %>% 
  na.omit() 

bfi_randint_test <- lmer(bfi_targ_pmc ~ bfi_self_pmc + 
                     (1 | sub_id), 
                   data = mod_1_data_bfi) # Model only works with the whole data-set (clean_data), not when filtered down to only include observations (thus none repeated) for this analysis with mod_1_data_bfi

summary(bfi_randint_test)
```

The intercept is equal to zero (which makes sense with the centered variables), but the variance for the intercet is also equal to zero. This indicates the intercepts for the subjects are all the same, which is weird.

### Checking individual intercepts/slopes

*Uncentered variables*

```{r}
bfi_coeffs_per_sub  <- lmList(bfi_targ ~ 1 + bfi_self | sub_id, mod_1_data_bfi)
bfi_coeffs_per_sub
```

*Person mean centered variables*

```{r}
bfi_coeffs_per_sub_c  <- lmList(bfi_targ_pmc ~ 1 + bfi_self_pmc | sub_id, mod_1_data_bfi)
bfi_coeffs_per_sub_c
```

There are a range of intercepts - does not appear there should be zero variance.

### Scatterplot of variables

```{r}
ggplot(mod_1_data_bfi, aes(bfi_self_pmc, bfi_targ_pmc)) +
  geom_point()
```

### More descriptives

```{r}
psych::describe(mod_1_data_bfi)
```

Re-checking the descriptives of these particular variables and they look normal.

## Random Slopes/No random Intercept

I think the singularities had to do with zero variance of the random intercept. To account for this, I am removing the random intercept.

```{r}
bfi_randslopes_test <- lmer(bfi_targ_pmc ~ bfi_self_pmc + 
                     (0 + bfi_self_pmc | sub_id), 
                   data = mod_1_data_bfi) # Model only works with the whole data-set (clean_data), not when filtered down to only include observations (thus none repeated) for this analysis with mod_1_data_bfi

summary(bfi_randslopes_test)
```

The estimate for the fixed effect for bfi_self remains the same (within rounding), regardless of whether the intercept is included in the model or not. This confirms what Bolker states in Github book: https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

## ELI

## Random intercept

```{r}
mod_1_data_eli <- clean_data %>% 
  select(sub_id, eli_number, eli_targ_pmc, eli_self_pmc, itt_comp_gmc,
         target_condition, eli_targ, eli_self) %>% 
  unique() %>% 
  na.omit() 

eli_randint_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (1 | sub_id), 
                   data = mod_1_data_eli) # Same as above, works with clean_data but not the smaller df specific to this analysis

summary(eli_randint_test)
```

Same issue as with the BFI.

### Checking individual intercepts/slopes

*Person mean centered variables*

```{r}
eli_coeffs_per_sub_c  <- lmList(eli_targ_pmc ~ 1 + eli_self_pmc | sub_id, mod_1_data_eli)
eli_coeffs_per_sub_c
```

*Uncentered variables*

```{r}
eli_coeffs_per_sub  <- lmList(eli_targ ~ 1 + eli_self | sub_id, mod_1_data_eli)
eli_coeffs_per_sub
```

As with the BFI, there seems to be variability in the intercepts, even though lmer is not finding it.

### Scatterplot of variables

```{r}
ggplot(mod_1_data_eli, aes(eli_self_pmc, eli_targ_pmc)) +
  geom_point()
```

## Random Slopes/No random intercept

```{r}
eli_randslopes_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = mod_1_data_eli) # Same as above, works with clean_data but not the smaller df specific to this analysis


summary(eli_randslopes_test)
```

# Model 1: Threat on Counter-projection

## BFI

### Correlation matrix (multicolinearity)

```{r}
cor_predictors1 <- clean_data %>% 
  select(sub_id, bfi_number, bfi_self, bfi_targ, itt_comp) %>% 
  unique() %>% 
  na.omit() %>% 
  select(bfi_self, bfi_targ, itt_comp)

cor_matrix_predictors1 <- cor(cor_predictors1)
cor_matrix_predictors1

cor_plot_predictors1 <- corrplot(cor_matrix_predictors1, method = "number")

colnames(cor_plot_predictors1) = rep(c('BFI: Self',
                                       'BFI: Target',
                                       'Threat Composite'))

rownames(cor_plot_predictors1) = rep(c('BFI: Self',
                                       'BFI: Target',
                                       'Threat Composite'))
corrplot(cor_plot_predictors1, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         col.lim = c(0, 1),
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

### MLM Results

```{r}
model1_bfi_randslopes <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc + 
                     (0 + bfi_self_pmc | sub_id), 
                   data = mod_1_data_bfi) # Model only works with the whole data-set (clean_data), not when filtered down to only include observations (thus none repeated) for this analysis with mod_1_data_bfi

tab_model(model1_bfi_randslopes,
          digits = 3)
```

After removing the zero intercept and only allowing random slopes for responses for the self, the model ran without issues. Results indicate there is a main effect of threat on projection, where projection decreases as threat increases.

#### Simple Slopes

```{r}
threat_levels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07))
mod1_simpslopes_bfi <- emtrends(model1_bfi_randslopes, ~ itt_comp_gmc,
                              var ="bfi_self_pmc",
                              at = threat_levels)

mod1_simpslopes_bfi
```

#### Visualization

```{r}
mod1_bfi_maineffect <- effect("bfi_self_pmc:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07)),
                         mod = model1_bfi_randslopes)

mod1_bfi_maineffect <- as.data.frame(mod1_bfi_maineffect)
mod1_bfi_maineffect$itt_comp_gmc <- as.factor(mod1_bfi_maineffect$itt_comp_gmc)

ggplot(mod1_bfi_maineffect, aes(bfi_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target-level \nthreat",
                        breaks = c(-1.07, 0, 1.07), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(title = "Projection by target-level threat",
         subtitle = "Using the BFI",
       x = "BFI responses for self",
       y = "BFI responses for target")
```

## ELI

### Correlation matrix (multicolinearity)

```{r}
cor_predictors_eli <- clean_data %>% 
  select(sub_id, eli_number, eli_self, eli_targ, itt_comp) %>% 
  unique() %>% 
  na.omit() %>% 
  select(eli_self, eli_targ, itt_comp)

cor_matrix_predictors_eli <- cor(cor_predictors_eli)
cor_matrix_predictors_eli

cor_plot_predictors_eli <- corrplot(cor_matrix_predictors_eli, method = "number")

colnames(cor_plot_predictors_eli) = rep(c('ELI: Self',
                                      'ELI: Target',
                                      'Threat Composite'))

rownames(cor_plot_predictors_eli) = rep(c('ELI: Self',
                                      'ELI: Target',
                                      'Threat Composite'))
corrplot(cor_plot_predictors_eli, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         col.lim = c(0, 1),
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

### MLM Results

```{r}
model1_eli_randslopes <- lmer(eli_targ_pmc ~ eli_self_pmc*itt_comp_gmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = mod_1_data_eli) # Same as above, works with clean_data but not the smaller df specific to this analysis


summary(model1_eli_randslopes)
tab_model(model1_eli_randslopes,
          digits = 3)
```

#### Simple Slopes

```{r}
mod1_simpslopes_eli <- emtrends(model1_eli_randslopes, ~ itt_comp_gmc,
                              var ="eli_self_pmc",
                              at = threat_levels)

mod1_simpslopes_eli
```

#### Visualization

```{r}
mod1_eli_maineffect <- effect("eli_self_pmc:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0, 1.07)),
                         mod = model1_eli_randslopes)

mod1_eli_maineffect <- as.data.frame(mod1_eli_maineffect)
mod1_eli_maineffect$itt_comp_gmc <- as.factor(mod1_eli_maineffect$itt_comp_gmc)

ggplot(mod1_eli_maineffect, aes(eli_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target-level \nthreat",
                        breaks = c(-1.07, 0, 1.07), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(title = "Projection by target-level threat",
         subtitle = "Using the ELI",
       x = "ELI responses for self",
       y = "ELI responses for target")
```

# Model 2: Instructions on threat







