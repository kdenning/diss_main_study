---
title: "Mediational Model"
output: 
    html_document:
      code_download: TRUE
      toc: TRUE
      toc_float:
        collapsed: FALSE
      toc_depth: 1
      code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r data prep, echo = FALSE, warning = FALSE, message = FALSE, error = FALSE}
# Loading packages
library(psych)
library(lme4)
library(nlme)
library(sjPlot)
library(effects)
library(magrittr) # part of the tidyverse but must be read in on its own
library(parameters)
library(dplyr)
library(tidyr)
library(rio)
library(ggplot2)
library(emmeans)
library(corrplot)
library(doParallel) 
library(doRNG)

# Functions to clean document, get data from wide to long format
source("functions/Cleaning.R")

# Setting global chunk options
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)

options(scipen = 999)

# Importing data
wide_data <- import("data/diss_main_combined_data_basic_clean.csv")

# wide_data_sub <- wide_data %>%
#   select(sub_id,
#          bfi_self_1:eli_self_10,
#          bfi_ster_1:eli_stereo_10,
#          bfi_targ_1:eli_targ_10)
# 
# bias_counts <- apply(wide_data_sub, 1, function(x) length(which(x=="3")))
# bias_counts <- as.data.frame(bias_counts)
# 
# total_answers <- length(wide_data_sub)
# 
# # Used the sub_ids obtained from below in function above
# bias_counts %>%
#   mutate(bias_percents = (bias_counts/total_answers)*100) %>%
#   filter(bias_percents > 50)
# 
# 
# wide_data <- wide_data[-c(12, 17, 18, 22, 24, 31, 40, 70, 78, 82, 86, 87, 99, 
#                           112, 130, 131, 144, 145, 147, 154, 165, 166, 180, 192, 
#                           216, 247, 253, 258, 265, 275, 291, 293, 313, 324, 349,
#                           362, 375, 385, 387, 409, 410, 460, 474, 483, 486), ] 

# Cleaning data using functions
long_data_bfi <- get_wrangled_bfi(wide_data)
long_data_eli <- get_wrangled_eli(wide_data)

clean_vars_bfi <- get_vars_cleaned(long_data_bfi)
clean_vars_eli <- get_vars_cleaned(long_data_eli)

clean_data_bfi <- remove_participants(clean_vars_bfi)
clean_data_eli <- remove_participants(clean_vars_eli)

clean_data_bfi %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = itt_comp - mean(itt_comp, na.rm = TRUE))

clean_data_eli %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = scale(itt_comp, center = T, scale = F))
```

# Exploring variance in intercepts for ELI

 https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

## Random intercept

```{r}
eli_data <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_targ_pmc, eli_self_pmc, itt_comp_gmc,
         target_condition, eli_targ, eli_self, eli_stereo, eli_stereo_pmc,
         analog_condition) %>% 
  unique() %>% 
  na.omit() 

eli_randint_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (1 | sub_id), 
                   data = eli_data) # Same as above, works with clean_data but not the smaller df specific to this analysis

summary(eli_randint_test)
```

The random variance for the intercept is 0, which is causing the singularity. This does not occur with the BFI. The data looks normal in the descriptives document. Checking some more stuff below.

### Checking individual intercepts/slopes

*Person mean centered variables*

```{r}
eli_coeffs_per_sub_c  <- lmList(eli_targ_pmc ~ 1 + eli_self_pmc | sub_id, eli_data)
eli_coeffs_per_sub_c
```

*Uncentered variables*

```{r}
eli_coeffs_per_sub  <- lmList(eli_targ ~ 1 + eli_self | sub_id, eli_data)
eli_coeffs_per_sub
```

There seems to be variability in the intercepts, even though lmer is not finding it.

### Scatterplot of variables

```{r}
ggplot(clean_data_eli, aes(eli_self_pmc, eli_targ_pmc)) +
  geom_point()
```

## Random Slopes/No random intercept

```{r}
eli_randslopes_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = eli_data) 


summary(eli_randslopes_test)
```

Running without the random intercept fixes the issue

# Model 1: Threat on Counter-projection

## BFI

### Correlation matrix (multicolinearity)

```{r}
cor_predictors1 <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_self, bfi_targ, itt_comp) %>% 
  unique() %>% 
  na.omit() %>% 
  select(bfi_self, bfi_targ, itt_comp)

cor_matrix_predictors1 <- cor(cor_predictors1)
cor_matrix_predictors1

cor_plot_predictors1 <- corrplot(cor_matrix_predictors1, method = "number")

colnames(cor_plot_predictors1) = rep(c('BFI: Self',
                                       'BFI: Target',
                                       'Threat Composite'))

rownames(cor_plot_predictors1) = rep(c('BFI: Self',
                                       'BFI: Target',
                                       'Threat Composite'))
corrplot(cor_plot_predictors1, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         col.lim = c(0, 1),
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

### MLM Results

```{r}
bfi_data <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_targ_pmc, bfi_self_pmc, itt_comp_gmc,
         target_condition, bfi_targ, bfi_self, bfi_stereo, bfi_stereo_pmc,
         analog_condition) %>% 
  unique() %>% 
  na.omit() 

model1_bfi <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc + 
                     (bfi_self_pmc | sub_id), 
                   data = bfi_data) # Model only works with the whole data-set (clean_data), not when filtered down to only include observations (thus none repeated) for this analysis with mod_1_data_bfi

tab_model(model1_bfi,
          digits = 3)
```

#### Simple Slopes

```{r}
threat_levels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07))
mod1_simpslopes_bfi <- emtrends(model1_bfi, ~ itt_comp_gmc,
                              var ="bfi_self_pmc",
                              at = threat_levels)

mod1_simpslopes_bfi
```

#### Visualization

```{r}
mod1_bfi_maineffect <- effect("bfi_self_pmc:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07)),
                         mod = model1_bfi)

mod1_bfi_maineffect <- as.data.frame(mod1_bfi_maineffect)
mod1_bfi_maineffect$itt_comp_gmc <- as.factor(mod1_bfi_maineffect$itt_comp_gmc)

ggplot(mod1_bfi_maineffect, aes(bfi_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target-level \nthreat",
                        breaks = c(-1.07, 0, 1.07), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(title = "Projection by target-level threat",
         subtitle = "Using the BFI",
       x = "BFI responses for self",
       y = "BFI responses for target")
```

## ELI

### Correlation matrix (multicolinearity)

```{r}
cor_predictors_eli <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_self, eli_targ, itt_comp) %>% 
  unique() %>% 
  na.omit() %>% 
  select(eli_self, eli_targ, itt_comp)

cor_matrix_predictors_eli <- cor(cor_predictors_eli)
cor_matrix_predictors_eli

cor_plot_predictors_eli <- corrplot(cor_matrix_predictors_eli, method = "number")

colnames(cor_plot_predictors_eli) = rep(c('ELI: Self',
                                      'ELI: Target',
                                      'Threat Composite'))

rownames(cor_plot_predictors_eli) = rep(c('ELI: Self',
                                      'ELI: Target',
                                      'Threat Composite'))
corrplot(cor_plot_predictors_eli, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         col.lim = c(0, 1),
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

### MLM Results

```{r}
model1_eli_randslopes <- lmer(eli_targ_pmc ~ eli_self_pmc*itt_comp_gmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = eli_data) # Same as above, works with clean_data but not the smaller df specific to this analysis


summary(model1_eli_randslopes)
tab_model(model1_eli_randslopes,
          digits = 3)
```

#### Simple Slopes

```{r}
mod1_simpslopes_eli <- emtrends(model1_eli_randslopes, ~ itt_comp_gmc,
                              var ="eli_self_pmc",
                              at = threat_levels)

mod1_simpslopes_eli
```

#### Visualization

```{r}
mod1_eli_maineffect <- effect("eli_self_pmc:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0, 1.07)),
                         mod = model1_eli_randslopes)

mod1_eli_maineffect <- as.data.frame(mod1_eli_maineffect)
mod1_eli_maineffect$itt_comp_gmc <- as.factor(mod1_eli_maineffect$itt_comp_gmc)

ggplot(mod1_eli_maineffect, aes(eli_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target-level \nthreat",
                        breaks = c(-1.07, 0, 1.07), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(title = "Projection by target-level threat",
         subtitle = "Using the ELI",
       x = "ELI responses for self",
       y = "ELI responses for target")
```

# Model 2: Instructions on threat

```{r}
contrasts(clean_data_bfi$analog_condition)
mod2_data <- clean_data_bfi %>% 
  select(sub_id, itt_comp_gmc, analog_condition, target_condition) %>% 
  unique()

mod2 <- lm(itt_comp_gmc ~ analog_condition, data = mod2_data)
summary(mod2)
```

```{r}
mod2_data %>% 
  group_by(analog_condition) %>% 
  mutate(mean = mean(itt_comp_gmc)) %>% 
  select(analog_condition, mean) %>% 
  unique()

```

# Model 2b: Instructions x Target Variable on Threat

```{r}
mod2b <- lm(itt_comp ~ analog_condition*target_condition, data = mod2_data)
summary(mod2b)
```

# Models 3a and 3b: Mediated effect on projection without bootstrapping

## 3a: Target by condition on projection 

### BFI 

```{r}
mod3a_bfi <- lmer(bfi_targ ~ bfi_self_pmc*analog_condition*target_condition +
       (bfi_self_pmc| sub_id), data = bfi_data)
summary(mod3a_bfi)

tab_model(mod3a_bfi)
```

Analog does not appear to have an affect, so threat will have nothing to affect...

### ELI

```{r}
mod3a_eli <- lmer(eli_targ ~ eli_self_pmc*analog_condition*target_condition +
       (0 + eli_self_pmc | sub_id), data = eli_data)
summary(mod3a_eli)

tab_model(mod3a_eli)
```
 
 
## 3b: Analog by threat composite on projection

### BFI 

```{r}
mod3b_bfi <- lmer(bfi_targ ~ bfi_self_pmc*analog_condition*itt_comp_gmc +
       (bfi_self_pmc| sub_id), data = bfi_data)
summary(mod3b_bfi)

tab_model(mod3b_bfi)
```

### ELI

```{r}
mod3b_eli <- lmer(eli_targ_pmc ~ eli_self_pmc*analog_condition*itt_comp_gmc +
       (0 + eli_self_pmc | sub_id), data = eli_data)
summary(mod3b_eli)

tab_model(mod3b_eli)
```

# Bootstrapping

## BFI

```{r parallel processing version}
# Set-up for mediational model -------------------------------------------------
# Getting basic data cleaning data before for loops
data_4_med_bfi <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_targ_pmc, bfi_self_pmc, itt_comp_gmc,
         target_condition, analog_condition) %>% 
  unique()

df_ids <- data_4_med_bfi %>% 
    select(sub_id) %>% 
    unique()

df_items <- data_4_med_bfi %>% 
  group_by(sub_id)

# Empty df
   empty_df <- data.frame(matrix(vector(mode = 'numeric',length = 1), nrow = 1, ncol = 16))
  
# Renaming variables appropriately
  empty_df %<>%
    rename(a = X1,
         a_cil =  X2,
         a_ciu = X3,
         b = X4,
         b_cil = X5,
         b_ciu = X6,
         c = X7,
         c_cil = X8,
         c_ciu = X9,
         c_prime = X10,
         c_prime_cil = X11,
         c_prime_ciu = X12,
         int_on_cp_coeff = X13,
         int_on_cp_cil = X14,
         int_on_cp_ciu = X15,
         total = X16
         )

# Seeting up multiple cores
registerDoParallel(8)

# Set seed for multiple cores
registerDoRNG(1)

# Trials to be run
trials <- 10000

# Looping with parallel processing with doParallel -----------------------------
## Keeping track of how long it takes
## 5 seconds versus 22 seconds per iteration without parallel processing
system.time({
med_df <- foreach(icount(trials)) %dopar% {
  # Getting samples ------------------------------------------------------------
  df_id_samp  <- df_ids %>% 
    slice_sample(n = 415)
  
  df_item_samp <- df_items %>% 
  sample_n(size = 19, replace = TRUE)
  
  df_samp <- left_join(df_id_samp, df_item_samp)
  
  df_lm <- df_samp %>% 
    select(sub_id, itt_comp_gmc, analog_condition) %>% 
    unique()
  
  # Running model for non-mediated effect---------------------------------------
  pt_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*analog_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # Getting coefficients for direct effect of PT, non-mediated
  fixed_eff_pt_on_cp <- fixef(pt_on_cp) 
  c <- fixed_eff_pt_on_cp[4] # non mediated effect of analog pt on projection

  # Getting cis for non-mediated direct effect
  pt_on_cp_direct_ci <- confint(pt_on_cp,level=0.95)
  c_cil <- pt_on_cp_direct_ci[8,1]
  c_ciu <- pt_on_cp_direct_ci[8,2]
  
  # Running model on indirect effect--------------------------------------------
  pt_on_threat <- lm(itt_comp_gmc ~ analog_condition, data = df_lm)
  
  # Getting coefficient for indirect
  a <- pt_on_threat$coefficients[2] # effect of analog on threat; a
  
  # Getting indirect CI
  lm_ci <- confint(pt_on_threat,level=0.95)
  a_cil <- lm_ci[2,1]
  a_ciu <- lm_ci[2,2]
  
  # Running model on direct, mediated effect -----------------------------------
  threat_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc*analog_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # getting fixed effects from lmer into subsettable format
  fixed_eff <- fixef(threat_on_cp) 
  b <- fixed_eff[5] # effect of threat on projection; b
  c_prime <- fixed_eff[6] # effect of pt on projection after accounting for threat; c'
  int_on_cp_coeff <- fixed_eff[8] # interaction on projection; do I need this?
  
  # Getting CIs for lmer model
  indirect_ci <- confint(threat_on_cp,level=0.95)
  b_cil <- indirect_ci[9,1]
  b_ciu <- indirect_ci[9,2]
  c_prime_cil <- indirect_ci[10,1]
  c_prime_ciu <- indirect_ci[10,2]
  int_on_cp_cil <- indirect_ci[12,1]
  int_on_cp_ciu <- indirect_ci[12,2]
  
  # Putting coefficients into overall df----------------------------------------
  empty_df$a[1] <- round(a, digits = 3)
  empty_df$a_cil[1] <- round(a_cil, digits = 3)
  empty_df$a_ciu[1] <- round(a_ciu, digits = 3)
  empty_df$b[1] <- round(b, digits = 3)
  empty_df$b_cil[1] <- round(b_cil, digits = 3)
  empty_df$b_ciu[1] <- round(b_ciu, digits = 3)
  empty_df$c[1] <- round(c, digits = 3)
  empty_df$c_cil[1] <- round(c_cil, digits = 3)
  empty_df$c_ciu[1] <- round(c_ciu, digits = 3)
  empty_df$c_prime[1] <- round(c_prime, digits = 3)
  empty_df$c_prime_cil[1] <- round(c_prime_cil, digits = 3)
  empty_df$c_prime_ciu[1] <- round(c_prime_ciu, digits = 3)
  empty_df$int_on_cp_coeff[1] <- round(int_on_cp_coeff, digits = 3) # do I need this?
  empty_df$int_on_cp_cil[1] <- round(int_on_cp_cil,digits = 3) # do I need this?
  empty_df$int_on_cp_ciu[1] <- round(int_on_cp_ciu, digits = 3) # do I need this?
  empty_df$total[1] <- round(empty_df$a*empty_df$b+empty_df$c_prime, digits = 3) # Tested for one model and total = c output, which is what it should be
  coeffs <- rbind(data.frame(), empty_df)
  
  }
})

med_results <- do.call(rbind.data.frame, med_df)

med_ave_estimates <- med_results %>% 
  # Analog was the reference condition, but I pre-registered that the control would be; multiped by "-1" to change direction for 
  # estimates affected by this error: a, c, and c_prime
  mutate(a = a*-1, 
         c = c*-1,
         c_prime = c_prime*-1,
         # indirect effect
         axb = (a*b)) %>% 
  mutate(a_mean = mean(a), # analog pt on threat
         b_mean = mean(b), # threat on counter-projection
         c_mean = mean(c), # analog pt on counter-projection
         cprime_mean = mean(c_prime),# analog pt on counter-projection including threat as covariate in model
         axb_mean = mean(axb),
         a_med = median(a),
         b_med = median(b),
         c_med = median(c),
         axb_med = median(axb),
         cprime_med = median(c_prime),
         a_cil = quantile(a, probs = .025),
         a_ciu = quantile(a, probs = .975),
         b_cil = quantile(b, probs = .025),
         b_ciu = quantile(b, probs = .975),
         c_cil = quantile(c, probs = .025),
         c_ciu = quantile(c, probs = .975),
         cprime_cil = quantile(c_prime, probs = .025),
         cprime_ciu = quantile(c_prime, probs = .975),
         axb_cil = quantile(axb, probs = .025),
         axb_ciu = quantile(axb, probs = .975)) %>% 
  select(a_mean, b_mean, c_mean, cprime_mean, 
         a_med, b_med, c_med, cprime_med,
         a_cil, a_ciu, b_cil, b_ciu, c_cil, c_ciu, cprime_cil, cprime_ciu, 
         axb_mean, axb_med, axb_cil, axb_ciu) %>% 
  unique() %>% 
  pivot_longer(a_mean:axb_ciu,
               names_sep = "_",
               names_to = c("Estimate", "statistic")) %>% 
  pivot_wider(names_from = statistic, values_from = value)

med_ave_estimates

# Exported data to save outside r environment
# med_results %>% 
#   mutate(model = 1:10000) %>% 
#   write.csv('bootstrap_mediation_output.csv', row.names = F)


```

Did not use the for loop code because it was too slow and the computer kept stopping in the middle, but preserved below

```{r for loop}
pb = txtProgressBar(min = 1, max = 10000, style = 3)

empty_df <- data.frame(matrix(vector(mode = 'numeric',length = 10000), nrow = 10000, ncol = 16))
  
  # Renaming variables appropriately
  empty_df %<>%
    rename(a = X1,
         a_cil =  X2,
         a_ciu = X3,
         b = X4,
         b_cil = X5,
         b_ciu = X6,
         c = X7,
         c_cil = X8,
         c_ciu = X9,
         c_prime = X10,
         c_prime_cil = X11,
         c_prime_ciu = X12,
         int_on_cp_coeff = X13,
         int_on_cp_cil = X14,
         int_on_cp_ciu = X15,
         total = X16
         )

  set.seed(123)
  
for (i in 1:10000) {
  # Sample the df---------------------------------------------------------------
  # Getting a subset of ids
  # df_ids <- data_4_med_bfi %>% 
  #   select(sub_id) %>% 
  #   unique() %>% 
  #   sample_n(size = 424, replace = TRUE)
  
  setTxtProgressBar(pb,i)
  
  df_ids <- data_4_med_bfi %>% 
    select(sub_id) %>% 
    unique() %>% 
    slice_sample(n = 415)
  
  # Getting a randomly sampled set of items per each id
  df_items <- data_4_med_bfi %>% 
  group_by(sub_id) %>% 
  sample_n(size = 19, replace = TRUE)
  
  # Joining for a random sampled df of a subset of the sample
  df_samp <- left_join(df_ids, df_items)
  
  df_lm <- df_samp %>% 
    select(sub_id, itt_comp_gmc, analog_condition) %>% 
    unique()
  
  # Running model for non-mediated effect---------------------------------------
  pt_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*analog_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # Getting coefficients for direct effect of PT, non-mediated
  fixed_eff_pt_on_cp <- fixef(pt_on_cp) 
  c <- fixed_eff_pt_on_cp[4] # non mediated effect of analog pt on projection
  
  # Getting cis for non-mediated direct effect
  pt_on_cp_direct_ci <- confint(pt_on_cp,level=0.95)
  c_cil <- pt_on_cp_direct_ci[8,1]
  c_ciu <- pt_on_cp_direct_ci[8,2]
  
  # Running model on indirect effect--------------------------------------------
  pt_on_threat <- lm(itt_comp_gmc ~ analog_condition, data = df_lm)
  
  # Getting coefficient for indirect
  a <- pt_on_threat$coefficients[2] # effect of analog on threat; a
  
  # Getting indirect CI
  lm_ci <- confint(pt_on_threat,level=0.95)
  a_cil <- lm_ci[2,1]
  a_ciu <- lm_ci[2,2]
  
  # Running model on direct, mediated effect -----------------------------------
  threat_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc*analog_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # getting fixed effects from lmer into subsettable format
  fixed_eff <- fixef(threat_on_cp) 
  b <- fixed_eff[5] # effect of threat on projection; b
  c_prime <- fixed_eff[6] # effect of pt on projection after accounting for threat; c'
  int_on_cp_coeff <- fixed_eff[8] # interaction on projection; do I need this?
  
  # Getting CIs for lmer model
  indirect_ci <- confint(threat_on_cp,level=0.95)
  b_cil <- indirect_ci[9,1]
  b_ciu <- indirect_ci[9,2]
  c_prime_cil <- indirect_ci[10,1]
  c_prime_ciu <- indirect_ci[10,2]
  int_on_cp_cil <- indirect_ci[12,1]
  int_on_cp_ciu <- indirect_ci[12,2]
  
  # Putting coefficients into overall df----------------------------------------
  df_coeffs$a[i] <- round(a, digits = 3)
  df_coeffs$a_cil[i] <- round(a_cil, digits = 3)
  df_coeffs$a_ciu[i] <- round(a_ciu, digits = 3)
  df_coeffs$b[i] <- round(b, digits = 3)
  df_coeffs$b_cil[i] <- round(b_cil, digits = 3)
  df_coeffs$b_ciu[i] <- round(b_ciu, digits = 3)
  df_coeffs$c[i] <- round(c, digits = 3)
  df_coeffs$c_cil[i] <- round(c_cil, digits = 3)
  df_coeffs$c_ciu[i] <- round(c_ciu, digits = 3)
  df_coeffs$c_prime[i] <- round(c_prime, digits = 3)
  df_coeffs$c_prime_cil[i] <- round(c_prime_cil, digits = 3)
  df_coeffs$c_prime_ciu[i] <- round(c_prime_ciu, digits = 3)
  df_coeffs$int_on_cp_coeff[i] <- round(int_on_cp_coeff, digits = 3) # do I need this?
  df_coeffs$int_on_cp_cil[i] <- round(int_on_cp_cil,digits = 3) # do I need this?
  df_coeffs$int_on_cp_ciu[i] <- round(int_on_cp_ciu, digits = 3) # do I need this?
  df_coeffs$total[i] <- round(df_coeffs$a[i]*df_coeffs$b[i]+df_coeffs$c_prime[i], digits = 3) # Tested for one model and total = c output, which is what it should be

}

close(pb)
```

Things to do/check:

Multicolinearity across levels?