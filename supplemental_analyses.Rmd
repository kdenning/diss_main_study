---
title: "Supplemental Analyses"
output: 
    html_document:
      code_download: TRUE
      toc: TRUE
      toc_float:
        collapsed: FALSE
      toc_depth: 1
      code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r data prep, echo = FALSE, warning = FALSE, message = FALSE, error = FALSE}
# Loading packages
library(psych)
library(effects)
library(magrittr) # part of the tidyverse but must be read in on its own
library(parameters)
library(dplyr)
library(tidyr)
library(rio)
library(ggplot2)
library(emmeans)
library(lavaan)
library(lme4)
library(sjPlot)

# Functions to clean document, get data from wide to long format
source("functions/Cleaning.R")

# Setting global chunk options
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)

options(scipen = 999)

# Importing data
wide_data <- import("data/diss_main_combined_data_basic_clean.csv")

# Cleaning data using functions
long_data_bfi <- get_wrangled_bfi(wide_data)
long_data_eli <- get_wrangled_eli(wide_data)

clean_vars_bfi <- get_vars_cleaned(long_data_bfi)
clean_vars_eli <- get_vars_cleaned(long_data_eli)

clean_data_bfi <- remove_participants(clean_vars_bfi)
clean_data_eli <- remove_participants(clean_vars_eli)

clean_data_bfi %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = itt_comp - mean(itt_comp, na.rm = TRUE))

clean_data_eli %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = scale(itt_comp, center = T, scale = F))
```

# Intervention checks {.tabset .tabset-fade .tabset-pills}

## How much did they take Jen's perspective?

```{r}
pt_check_df <- clean_data_bfi %>% 
  select(sub_id, analog_condition, intervention_check1, intervention_check2, intervention_check3) %>% 
  unique() %>% 
  mutate(intervention_check1 = as.numeric(dplyr::recode(intervention_check1, #how much did you take Jen's perspective
                                             `Completely` = "4",
                                             `Moderately` = "3",
                                             `Slightly` = "2",
                                             `Not at all` = "1")), 
         intervention_check2 = as.numeric(dplyr::recode(intervention_check2, # How misunderstood is Jen
                                             `Always` = "4",
                                             `Slightly` = "3",
                                             `Rarely` = "2",
                                             `Not at all` = "1")))

pt_check_df %>% 
  group_by(analog_condition) %>% 
  mutate(mean = mean(intervention_check1),
         sd = sd(intervention_check1)) %>% 
  select(analog_condition, mean, sd) %>% 
  unique()
```

```{r}
int_check1_res <- aov(intervention_check1 ~ analog_condition, data = pt_check_df)
anova(int_check1_res)
```

How much they reported taking her perspective was not significantly different

## How misunderstood was Jen?

```{r}
pt_check_df %>% 
  group_by(analog_condition) %>% 
  mutate(mean = mean(intervention_check2),
         sd = sd(intervention_check2)) %>% 
  select(analog_condition, mean, sd) %>% 
  unique()
```

```{r}
int_check2_res <- aov(intervention_check2 ~ analog_condition, data = pt_check_df)
anova(int_check2_res)
```

How much they reported Jen was misunderstood was significantly different, with those in the analog condition saying she was more misunderstood. However, this did not have an effect on counter-projection.


# Checking mean/sd of bfi_self responses per item {.tabset .tabset-fade .tabset-pills}

```{r}
bfi_wide_self <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_self) %>% 
  unique() %>% 
  pivot_wider(names_from = bfi_number, values_from = bfi_self) %>% 
  select(sub_id, "1":"19") %>% 
  unique()

psych::describe(bfi_wide_self)
```

# Variance around threat composite by threat condition {.tabset .tabset-fade .tabset-pills}

```{r}
clean_data_bfi %>% 
  select(sub_id, itt_comp_gmc, target_condition) %>% 
  group_by(target_condition) %>% 
  mutate(mean = mean(itt_comp_gmc),
         sd = sd(itt_comp_gmc)) %>% 
  select(target_condition, mean, sd) %>% 
  unique()
```

## Control condition only

```{r}
filter_control <- clean_data_bfi %>% 
  filter(target_condition == "CONTROL")

hist(filter_control$itt_comp)
```

## Warm condition only

```{r}
filter_warm <- clean_data_bfi %>% 
  filter(target_condition == "WARM")

hist(filter_warm$itt_comp)
```

## Political loss condition only

```{r}
filter_loss <- clean_data_bfi %>% 
  filter(target_condition == "LOSS")

hist(filter_loss$itt_comp)
```

# Testing effect of centering

## Only composite

### erson mean centered

```{r}
data_bfi <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_targ_pmc, bfi_self_pmc, itt_comp_gmc,
         target_condition, bfi_targ, bfi_self, bfi_stereo, bfi_stereo_pmc,
         bfi_targ_gmc, bfi_self_gmc, bfi_stereo_gmc) %>% 
  unique() %>% 
  na.omit() 

bfi_pmc1 <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc +
                     (bfi_self_pmc | sub_id), data = data_bfi)
summary(bfi_pmc1)
tab_model(bfi_pmc1)
```

### Grand mean centered

```{r}
bfi_gmc1 <- lmer(bfi_targ ~ bfi_self_gmc*itt_comp_gmc +
                     (bfi_self_gmc | sub_id), data = data_bfi)
summary(bfi_gmc1)
tab_model(bfi_gmc1)
```

# Mediation of target condition by target-level threat


```{r parallel processing version}
# Set-up for mediational model -------------------------------------------------
# Getting basic data cleaning data before for loops
data_4_med_bfi <- clean_data_bfi %>% 
  select(sub_id, bfi_number, bfi_targ_pmc, bfi_self_pmc, itt_comp_gmc,
         target_condition) %>% 
  mutate(target_condition = forcats::fct_relevel(target_condition, c("CONTROL", "WARM", "LOSS"))) %>% 
  unique()
contrasts(data_4_med_bfi$target_condition)

my.helmert = matrix(c(2/3, -1/3, -1/3, 0, 1/2, -1/2), ncol = 2)
my.helmert

contrasts(data_4_med_bfi$target_condition) = my.helmert
df_ids <- data_4_med_bfi %>% 
    select(sub_id) %>% 
    unique()

df_items <- data_4_med_bfi %>% 
  group_by(sub_id)

# Empty df
   empty_df <- data.frame(matrix(vector(mode = 'numeric',length = 1), nrow = 1, ncol = 9))
  
# Renaming variables appropriately
  empty_df %<>%
    rename(a_cvl = X1,
         a_cvw =  X2,
         b = X3,
         c_cvl = X4,
         c_cvw = X5,
         c_prime_cvl = X6,
         c_prime_cvw = X7,
         total_cvl = X8,
         total_cvw = X9
         )

# Seeting up multiple cores
registerDoParallel(8)

# Set seed for multiple cores
registerDoRNG(1)

# Trials to be run
trials <- 10

# Looping with parallel processing with doParallel -----------------------------
## Keeping track of how long it takes
## 5 seconds versus 22 seconds per iteration without parallel processing
system.time({
med_df <- foreach(icount(trials)) %dopar% {
  # Getting samples ------------------------------------------------------------
  df_id_samp  <- df_ids %>% 
    slice_sample(n = 415)
  
  df_item_samp <- df_items %>% 
  sample_n(size = 19, replace = TRUE)
  
  df_samp <- left_join(df_id_samp, df_item_samp)
  
  df_lm <- df_samp %>% 
    select(sub_id, itt_comp_gmc, target_condition) %>% 
    unique()
  
  # Running model for non-mediated effect---------------------------------------
  targ_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*target_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # Getting coefficients for direct effect of PT, non-mediated
  fixed_eff_targ_on_cp <- fixef(targ_on_cp) 
  c_cvw <- fixed_eff_targ_on_cp[5] # non mediated effect of target condition on projection
  c_cvl <- fixed_eff_targ_on_cp[6]
  
  # I did not use the ci's per model last time - to save on processing power, they are removed
  
  # Running model on indirect effect--------------------------------------------
  targ_on_threat <- lm(itt_comp_gmc ~ target_condition, data = df_lm)
  
  # Getting coefficient for indirect
  a_cvw <- targ_on_threat$coefficients[2] # effect of analog on threat; a
  a_cvl <- targ_on_threat$coefficients[3]
  
  # Running model on direct, mediated effect -----------------------------------
  threat_on_cp <- lmer(bfi_targ_pmc ~ bfi_self_pmc*itt_comp_gmc*target_condition +
                         (bfi_self_pmc | sub_id), 
                   data = df_samp)
  
  # getting fixed effects from lmer into subsettable format
  fixed_eff <- fixef(threat_on_cp) 
  b <- fixed_eff[6] # effect of threat on projection; b
  c_prime_cvw <- fixed_eff[7] # effect of pt on projection after accounting for threat; c'
  c_prime_cvl <- fixed_eff[8] 
  #did not use interaction last time, so not pulling it to save processing power

  
  # Putting coefficients into overall df----------------------------------------
  empty_df$a_cvl[1] <- round(a_cvl, digits = 3)
  empty_df$a_cvw[1] <- round(a_cvw, digits = 3)
  empty_df$b[1] <- round(b, digits = 3)
  empty_df$c_cvl[1] <- round(c_cvl, digits = 3)
  empty_df$c_cvw[1] <- round(c_cvw, digits = 3)
  empty_df$c_prime_cvl[1] <- round(c_prime_cvl, digits = 3)
  empty_df$c_prime_cvw[1] <- round(c_prime_cvw, digits = 3)
  empty_df$total_cvl[1] <- round(empty_df$a_cvl*empty_df$b+empty_df$c_prime_cvl, digits = 3)
  empty_df$total_cvw[1] <- round(empty_df$a_cvw*empty_df$b+empty_df$c_prime_cvw, digits = 3) 
  coeffs <- rbind(data.frame(), empty_df)
  
  }
})

med_results <- do.call(rbind.data.frame, med_df)

med_ave_estimates <- med_results %>% 
  # Analog was the reference condition, but I pre-registered that the control would be; multiped by "-1" to change direction for 
  # estimates affected by this error: a, c, and c_prime
  mutate(a = a*-1, 
         c = c*-1,
         c_prime = c_prime*-1,
         # indirect effect
         axb = (a*b)) %>% 
  mutate(a_mean = mean(a), # analog pt on threat
         b_mean = mean(b), # threat on counter-projection
         c_mean = mean(c), # analog pt on counter-projection
         cprime_mean = mean(c_prime),# analog pt on counter-projection including threat as covariate in model
         axb_mean = mean(axb),
         a_med = median(a),
         b_med = median(b),
         c_med = median(c),
         axb_med = median(axb),
         cprime_med = median(c_prime),
         a_cil = quantile(a, probs = .025),
         a_ciu = quantile(a, probs = .975),
         b_cil = quantile(b, probs = .025),
         b_ciu = quantile(b, probs = .975),
         c_cil = quantile(c, probs = .025),
         c_ciu = quantile(c, probs = .975),
         cprime_cil = quantile(c_prime, probs = .025),
         cprime_ciu = quantile(c_prime, probs = .975),
         axb_cil = quantile(axb, probs = .025),
         axb_ciu = quantile(axb, probs = .975)) %>% 
  select(a_mean, b_mean, c_mean, cprime_mean, 
         a_med, b_med, c_med, cprime_med,
         a_cil, a_ciu, b_cil, b_ciu, c_cil, c_ciu, cprime_cil, cprime_ciu, 
         axb_mean, axb_med, axb_cil, axb_ciu) %>% 
  unique() %>% 
  pivot_longer(a_mean:axb_ciu,
               names_sep = "_",
               names_to = c("Estimate", "statistic")) %>% 
  pivot_wider(names_from = statistic, values_from = value)

med_ave_estimates

# Exported data to save outside r environment
# med_results %>% 
#   mutate(model = 1:10000) %>% 
#   write.csv('bootstrap_mediation_output.csv', row.names = F)
```

## Direct path c

```{r}
path_c2 <- lmer(bfi_targ_pmc ~ bfi_self_pmc*target_condition +
                     (bfi_self_pmc | sub_id), data = bfi_data)
summary(path_c2)
tab_model(path_c2)
```

### Simple Slopes

```{r}
targ_levels <-list(target_condition = c("CONTROL", "LOSS", "WARM"))
path_c2_effects <- emtrends(path_a2, ~ target_condition,
                              var ="bfi_self_pmc",
                              at = targ_levels)


path_a2_effects
test(path_c2_effects)
pairs(path_c2_effects)
```

### Visualization

```{r}
path_c2_data <- effect("bfi_self_pmc:target_condition",
                         xlevels = list(target_condition = c("CONTROL",
                                                             "WARM",
                                                             "LOSS")),
                         mod = path_c2)

path_c2_data <- as.data.frame(path_c2_data)
path_c2_data$target_condition <- as.factor(path_c2_data$target_condition)

path_c2_data %<>% 
  mutate(target_condition = forcats::fct_relevel(target_condition, c("CONTROL", "WARM", "LOSS")))

ggplot(path_c2_data, aes(bfi_self_pmc, fit, group = target_condition)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = TRUE,
                colour = "black", 
                aes(linetype = target_condition)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target Variable",
                        breaks = c("CONTROL", "WARM", "LOSS"), 
                       labels = c("Least threatening",
                                  "Medium threatening",
                                  "Most threatening"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(x = "BFI responses for self",
       y = "BFI responses for target")
```

### Assumptions

```{r}
# checking normality of conditional residuals
qqnorm(residuals(bfi_nostereo_targ), main="Q-Q plot for conditional residuals")

# checking the normality of the random effects (here random intercept):
qqnorm(ranef(bfi_nostereo_targ)$sub_id$bfi_self_pmc,
       main="Q-Q plot for the self random effect")

# Checking residuals for intercept
qqnorm(ranef(bfi_nostereo_targ)$sub_id$`(Intercept)`,
       main="Q-Q plot for the random intercept")

plot_model(bfi_nostereo_targ, type='diag')
```


