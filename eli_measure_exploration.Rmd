---
title: "Exploring the ELI Measure"
output: 
    html_document:
      code_download: TRUE
      toc: TRUE
      toc_float:
        collapsed: FALSE
      toc_depth: 1
      code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r data prep, echo = FALSE, warning = FALSE, message = FALSE, error = FALSE}
# Loading packages
library(psych)
library(lme4)
library(nlme)
library(sjPlot)
library(effects)
library(magrittr) # part of the tidyverse but must be read in on its own
library(parameters)
library(dplyr)
library(tidyr)
library(rio)
library(ggplot2)
library(emmeans)
library(corrplot)
library(doParallel) 
library(doRNG)

# Functions to clean document, get data from wide to long format
source("functions/Cleaning.R")

# Setting global chunk options
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)

options(scipen = 999)

# Importing data
wide_data <- import("data/diss_main_combined_data_basic_clean.csv")

# wide_data_sub <- wide_data %>%
#   select(sub_id,
#          bfi_self_1:eli_self_10,
#          bfi_ster_1:eli_stereo_10,
#          bfi_targ_1:eli_targ_10)
# 
# bias_counts <- apply(wide_data_sub, 1, function(x) length(which(x=="3")))
# bias_counts <- as.data.frame(bias_counts)
# 
# total_answers <- length(wide_data_sub)
# 
# # Used the sub_ids obtained from below in function above
# bias_counts %>%
#   mutate(bias_percents = (bias_counts/total_answers)*100) %>%
#   filter(bias_percents > 50)
# 
# 
# wide_data <- wide_data[-c(12, 17, 18, 22, 24, 31, 40, 70, 78, 82, 86, 87, 99, 
#                           112, 130, 131, 144, 145, 147, 154, 165, 166, 180, 192, 
#                           216, 247, 253, 258, 265, 275, 291, 293, 313, 324, 349,
#                           362, 375, 385, 387, 409, 410, 460, 474, 483, 486), ] 

# Cleaning data using functions
long_data_eli <- get_wrangled_eli(wide_data)

clean_vars_eli <- get_vars_cleaned(long_data_eli)

clean_data_eli <- remove_participants(clean_vars_eli)

clean_data_eli %<>%    
  mutate(itt_comp = rowMeans(select(., c("realistic_q", "symbolic_q"))),
         itt_comp_gmc = scale(itt_comp, center = T, scale = F))
```

# Exploring the ELI

```{r}
eli_data <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_targ_pmc, eli_self_pmc, itt_comp_gmc,
         target_condition, eli_targ, eli_self, eli_stereo, eli_stereo_pmc,
         analog_condition, itt_comp) %>% 
  unique() %>% 
  na.omit() 

eli5_data <- clean_data_eli %>% 
  filter(eli_number %in% c("1", "2", "3", "4", "5")) %>% 
  select(sub_id, eli_number, eli_targ_pmc, eli_self_pmc, itt_comp_gmc,
         target_condition, eli_targ, eli_self, eli_stereo, eli_stereo_pmc,
         analog_condition, itt_comp) %>% 
  unique() %>% 
  na.omit() 
```

```{r}
eli_wide_self <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_self, pol_orient_1, pol_orient_2, pol_orient_3) %>% 
  unique() %>% 
  pivot_wider(names_from = eli_number, values_from = eli_self) %>% 
  rename("Politics: Overall" = pol_orient_1,
         "Politics: Social" = pol_orient_2,
         "Politics: Economic" = pol_orient_3,
         "ElI 1" = `1`,
         "ElI 2" = `2`,
         "ElI 3" = `3`,
         "ElI 4" = `4`,
         "ElI 5" = `5`,
         "ElI 6" = `6`,
         "ElI 7" = `7`,
         "ElI 8" = `8`,
         "ElI 9" = `9`,
         "ElI 10" = `10`)
```

```{r}
# These look the same as in the PSPB paper
hist(eli_wide_self$`ElI 1`)
hist(eli_wide_self$`ElI 2`)
hist(eli_wide_self$`ElI 3`)
hist(eli_wide_self$`ElI 4`)
hist(eli_wide_self$`ElI 5`)
```


# Exploring relationship of ELI vars with each other and political orientation {.tabset .tabset-fade .tabset-pills}

## Self

```{r}
eli_self_cor <- eli_wide_self %>% 
  select(-sub_id)

eli_pol_cor <- cor(eli_self_cor)

corrplot(eli_pol_cor, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

Responses on the ELI are not related to responses on the political orientation questions nor each other (aka orthogonal)

## Target

```{r}
eli_wide_targ <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_targ, pol_orient_1, pol_orient_2, pol_orient_3) %>% 
  unique() %>% 
  pivot_wider(names_from = eli_number, values_from = eli_targ) %>% 
  select(-sub_id) %>% 
   rename("Politics: Overall" = pol_orient_1,
         "Politics: Social" = pol_orient_2,
         "Politics: Economic" = pol_orient_3,
         "ElI 1" = `1`,
         "ElI 2" = `2`,
         "ElI 3" = `3`,
         "ElI 4" = `4`,
         "ElI 5" = `5`,
         "ElI 6" = `6`,
         "ElI 7" = `7`,
         "ElI 8" = `8`,
         "ElI 9" = `9`,
         "ElI 10" = `10`)

eli_targ_matrix_targ <- cor(eli_wide_targ)

corrplot(eli_targ_matrix_targ, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')
```

The target has slightly higher correlations overall for the ELI, but lower ones in relation to political orientation

## Stereo

```{r}
eli_wide_stereo <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_stereo, pol_orient_1, pol_orient_2, pol_orient_3) %>% 
  unique() %>% 
  pivot_wider(names_from = eli_number, values_from = eli_stereo) %>% 
     rename("Politics: Overall" = pol_orient_1,
         "Politics: Social" = pol_orient_2,
         "Politics: Economic" = pol_orient_3,
         "ElI 1" = `1`,
         "ElI 2" = `2`,
         "ElI 3" = `3`,
         "ElI 4" = `4`,
         "ElI 5" = `5`,
         "ElI 6" = `6`,
         "ElI 7" = `7`,
         "ElI 8" = `8`,
         "ElI 9" = `9`,
         "ElI 10" = `10`) %>% 
    select(-sub_id)

eli_stereo_matrix_stereo <- cor(eli_wide_stereo)

corrplot(eli_stereo_matrix_stereo, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50')

```

Again, higher correlations than for the self, but still only .35 as the highest. Low correlations with politics, but higher than with the target.

# Exploring variance in intercepts for ELI

 https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

## Random intercept

### With self

```{r}

eli_randint_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (1 | sub_id), 
                   data = eli_data) # Same as above, works with clean_data but not the smaller df specific to this analysis

summary(eli_randint_test)
```

The random variance for the intercept is 0, which is causing the singularity. This does not occur with the BFI. The data looks normal in the descriptives document. Checking some more stuff below.

### Checking individual intercepts/slopes

*Person mean centered variables*

```{r}
eli_coeffs_per_sub_c  <- lmList(eli_targ_pmc ~ 1 + eli_self_pmc | sub_id, eli_data)
eli_coeffs_per_sub_c
```

*Uncentered variables*

```{r}
eli_coeffs_per_sub  <- lmList(eli_targ ~ 1 + eli_self | sub_id, eli_data)
eli_coeffs_per_sub
```

There seems to be variability in the intercepts, even though lmer is not finding it.

### Scatterplot of variables

```{r}
ggplot(clean_data_eli, aes(eli_self_pmc, eli_targ_pmc)) +
  geom_point()
```

### Random intercept only

```{r}

eli_randint_only <- lmer(eli_targ_pmc ~ 1 + # itt does not work as a RE; model does not converge
                     (1 | sub_id), 
                   data = eli_data) # Same as above, works with clean_data but not the smaller df specific to this analysis

summary(eli_randint_only)
```

## With only first five ELI items

These were the ones used in the PSPB paper

```{r}

eli5_randint_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (1 | sub_id), 
                   data = eli5_data) # Same as above, works with clean_data but not the smaller df specific to this analysis

summary(eli5_randint_test)
```

## Random Slopes/No random intercept

```{r}
eli_randslopes_test <- lmer(eli_targ_pmc ~ eli_self_pmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = eli_data) 


summary(eli_randslopes_test)
```

Running without the random intercept fixes the issue

# Running models with random slopes/no intercepts {.tabset .tabset-fade .tabset-pills}

## Threat composite 

```{r}
comp_eli_randslopes <- lmer(eli_targ_pmc ~ eli_self_pmc*itt_comp_gmc + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = eli_data) # Same as above, works with clean_data but not the smaller df specific to this analysis


summary(comp_eli_randslopes)
tab_model(comp_eli_randslopes,
          digits = 3)
```

### Simple slopes

```{r}
threat_levels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07))
comp_simpslopes_eli <- emtrends(comp_eli_randslopes, ~ itt_comp_gmc,
                              var ="eli_self_pmc",
                              at = threat_levels)

comp_simpslopes_eli 
test(comp_simpslopes_eli)
pairs(comp_simpslopes_eli)
```

### Visualization

```{r}
comp_eli_maineffect <- effect("eli_self_pmc:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0, 1.07)),
                         mod = comp_eli_randslopes)

comp_eli_maineffect <- as.data.frame(comp_eli_maineffect)
comp_eli_maineffect$itt_comp_gmc <- as.factor(comp_eli_maineffect$itt_comp_gmc)

ggplot(comp_eli_maineffect, aes(eli_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target-level threat",
                        breaks = c(-1.07, 0, 1.07), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(x = "ELI responses for self",
       y = "ELI responses for target")
```

### Assumptions

```{r}
# checking normality of conditional residuals
qqnorm(residuals(comp_eli_randslopes), main="Q-Q plot for conditional residuals")

# checking the normality of the random effects (here random intercept):
qqnorm(ranef(comp_eli_randslopes)$sub_id$eli_self_pmc,
       main="Q-Q plot for the self random effect")

plot_model(comp_eli_randslopes, type='diag')
```

Also seems evenly spread but diagonal

## Target variable

```{r}
cond_eli_randslopes <- lmer(eli_targ_pmc ~ eli_self_pmc*target_condition + # itt does not work as a RE; model does not converge
                     (0 + eli_self_pmc | sub_id), 
                   data = eli_data) # Same as above, works with clean_data but not the smaller df specific to this analysis


summary(cond_eli_randslopes)
tab_model(cond_eli_randslopes,
          digits = 3)
```

### Simple Slopes

```{r}
targ_levels <-list(target_condition = c("CONTROL", "LOSS", "WARM"))
simpslopes_eli_nostereo_cond <- emtrends(cond_eli_randslopes, ~ target_condition,
                              var ="eli_self_pmc",
                              at = targ_levels)


simpslopes_eli_nostereo_cond 
pairs(simpslopes_eli_nostereo_cond)
test(simpslopes_eli_nostereo_cond)
```

### Assumptions

```{r}
# checking normality of conditional residuals
qqnorm(residuals(cond_eli_randslopes), main="Q-Q plot for conditional residuals")

# checking the normality of the random effects
qqnorm(ranef(cond_eli_randslopes)$sub_id$eli_self_pmc,
       main="Q-Q plot for the self random effect")

plot_model(cond_eli_randslopes, type='diag')
```

Heavy tail?

Also seems evenly spread but diagonal

### Visualization

```{r}
eli_data %<>% 
  mutate(target_condition = forcats::fct_relevel(target_condition, c("CONTROL", "WARM", "LOSS")))

target_labels <- c("CONTROL" = "Control target",
                   "WARM" = "Warm target",
                   "LOSS" = "Loss target")

eli_cond_df <- effect("eli_self_pmc:target_condition",
                         xlevels = list(target_condition = c("CONTROL",
                                                             "WARM",
                                                             "LOSS")),
                         mod = cond_eli_randslopes)

eli_cond_df <- as.data.frame(eli_cond_df)
eli_cond_df$target_condition <- as.factor(eli_cond_df$target_condition)

ggplot(eli_cond_df, aes(eli_self_pmc, fit, group = target_condition)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = target_condition)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  scale_linetype_manual("Target Variable",
                        breaks = c("CONTROL", "WARM", "LOSS"), 
                       labels = c("Least threatening",
                                  "Medium threatening",
                                  "High threatening"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) 
    labs(x = "ELI responses for self",
       y = "ELI responses for target")
```

## Analog x threat composite

```{r}
analogcomp_eli_randslopes <- lmer(eli_targ ~ eli_self_pmc*analog_condition*itt_comp_gmc +
       (0 + eli_self_pmc | sub_id), data = eli_data)
summary(analogcomp_eli_randslopes)

tab_model(analogcomp_eli_randslopes)
```

## Analog x threat composite - residual

```{r}
eli_data %<>% 
  mutate(analog_condition = forcats::fct_relevel(analog_condition,
                                                        c("control",
                                                        "analog")))
contrasts(eli_data$analog_condition)

analogcompresid_eli_randslopes <- lmer(eli_targ_pmc ~ eli_self_pmc*analog_condition*itt_comp_gmc*eli_stereo_pmc +
       (0 + eli_self_pmc | sub_id), data = eli_data)
summary(analogcompresid_eli_randslopes)

tab_model(analogcompresid_eli_randslopes)
confint(analogcompresid_eli_randslopes)

threat_levels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07))
analog_levels = list(analog_condition = c("analog", "control"))
simslopes_analog_resid <- emtrends(analogcompresid_eli_randslopes, ~ itt_comp_gmc*analog_condition,
                              var ="eli_self_pmc",
                              at = c(threat_levels, analog_levels))


simslopes_analog_resid
test(simslopes_analog_resid)
pairs(simslopes_analog_resid)
```


### Visualization

```{r}
analog_resid_df <- effect("eli_self_pmc:analog_condition:itt_comp_gmc",
                         xlevels = list(itt_comp_gmc = c(-1.07, 0.0, 1.07),
                                        analog_condiion = "analog", "control"),
                         mod = analogcompresid_eli_randslopes)

analog_resid_df <- as.data.frame(analog_resid_df)
analog_resid_df$itt_comp_gmc <- as.factor(analog_resid_df$itt_comp_gmc)
analog_resid_df$analog_condition <- as.factor(analog_resid_df$analog_condition)

analog_resid_df %<>% 
         mutate(analog_condition = dplyr::recode(analog_condition,
                                         `analog` = "Analogous instruction \ncondition",
                                         `control` = "Control condition"))

  

ggplot(analog_resid_df, aes(eli_self_pmc, fit, group = itt_comp_gmc)) +
  geom_smooth(method = "lm", 
                size = .7, 
                se = FALSE,
                colour = "black", 
                aes(linetype = itt_comp_gmc)) +
    theme_minimal(base_size = 13) +
    theme(legend.key.size = unit(1, "cm")) +
  facet_wrap(vars(analog_condition)) +
  scale_linetype_manual("Target-level threat",
                        breaks = c("-1.07", "0", "1.07"), 
                       labels = c("Low",
                                  "Average",
                                  "High"),
                       values = c("solid",
                                  "dashed",
                                  "dotted")) +
    labs(x = "BFI responses for self",
       y = "BFI responses for target")
```

## Analog x target variable

```{r}
analogcond_eli_randslopes <- lmer(eli_targ ~ eli_self_pmc*analog_condition*target_condition +
       (0 + eli_self_pmc | sub_id), data = eli_data)
summary(analogcond_eli_randslopes)

tab_model(analogcond_eli_randslopes)
```

# Correlation matrix (multicolinearity) {.tabset .tabset-fade .tabset-pills}

```{r}
cor_predictors_eli <- clean_data_eli %>% 
  select(sub_id, eli_number, eli_self, eli_targ, itt_comp) %>% 
  unique() %>% 
  na.omit() %>% 
  select(eli_self, eli_targ, itt_comp) %>% 
  rename("ELI: Self" = eli_self,
         "ELI: Target" = eli_targ,
         "Threat Composite" = itt_comp)

cor_matrix_predictors_eli <- cor(cor_predictors_eli)

corrplot(cor_matrix_predictors_eli, 
         is.corr = TRUE, 
         #method = "number", 
         method = 'color',
         tl.cex = .85,
         tl.col = 'black',
         addgrid.col = 'white',
         addCoef.col = 'grey50',
         type = 'lower')
```

